searchState.loadedDescShard("virtio_drivers", 0, "VirtIO guest drivers.\nThe queue is already in use.\nThe buffer may be read or written by both the device and …\nThe direction in which a buffer is passed.\nThe device doesn’t have any config space, but the driver …\nThe config space advertised by the device is smaller than …\nThe buffer may be read or written by the device, but only …\nFailed to alloc DMA memory.\nThe buffer may be read or written by the driver, but only …\nContains the error value\nThe error type of VirtIO drivers.\nThe interface which a particular hardware implementation …\nInvalid parameter.\nI/O Error\nThe device is not ready.\nContains the success value\nThe page size in bytes supported by the library (4 KiB).\nA physical address as used for virtio.\nThere are not enough descriptors available in the …\nThe type returned by driver methods.\nError from the socket device.\nThe request was not supported by the device.\nThe device used a different descriptor chain to the one we …\nDrivers for specific VirtIO devices.\nAllocates and zeroes the given number of contiguous …\nDeallocates the given contiguous physical DMA memory pages.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a physical address used for MMIO to a virtual …\nShares the given memory range with the device, and returns …\nVirtIO transports.\nUnshares the given memory range from the device and (if …\nDriver for VirtIO block devices.\nDriver for VirtIO network devices.\nDriver for VirtIO socket devices.\nA VirtIO block device request.\nResponse of a VirtIOBlk request.\nIoErr.\nNot ready.\nOk.\nStatus of a VirtIOBlk request.\nThe standard sector size of a VirtIO block device. Data is …\nUnsupported yet.\nDriver for a VirtIO block device.\nAcknowledges a pending interrupt, if any.\nGets the capacity of the block device, in 512 byte (…\nCompletes a read operation which was started by …\nCompletes a write operation which was started by …\nGets the device ID.\nRequests the device to flush any pending writes to storage.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new VirtIO-Blk driver.\nFetches the token of the next completed request from the …\nReads one or more blocks into the given buffer.\nSubmits a request to read one or more blocks, but returns …\nReturns true if the block device is read-only, or false if …\nReturn the status of a VirtIOBlk request.\nReturns the size of the device’s VirtQueue.\nWrites the contents of the given buffer to a block or …\nSubmits a request to write one or more blocks, but returns …\nRaw driver for a VirtIO block device.\nVirtIO 5.1.6 Device Operation:\nAcknowledge interrupt.\nWhether can send packet.\nDisable interrupts.\nEnable interrupts.\nFill the header of the <code>buffer</code> with <code>VirtioNetHdr</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet MAC address.\nCreate a new VirtIO-Net driver.\nFetches the token of the next completed reception request …\nFetches the token of the next completed transmission …\nSubmits a request to receive a buffer immediately without …\nCompletes a transmission operation which was started by …\nBlocks and waits for a packet to be received.\nSends a packet to the network, and blocks until the …\nSubmits a request to transmit a buffer immediately without …\nCompletes a transmission operation which was started by …\nThe given buffer has exceeded the maximum buffer size.\nThe given buffer is shorter than expected.\nThere is an existing connection.\nFailed to establish the connection.\nPeer has insufficient buffer space, try again later.\nInvalid number.\nInvalid operation,\nNo response received.\nThe device is not connected to any peer.\nThe given buffer for output is shorter than expected.\nPeer socket is shutdown.\nRecycled a wrong buffer.\nThe error type of VirtIO socket driver.\nUnexpected data in packet.\nUnknown operation.\nWell-known CID for the host.\nSocket address.\nContext Identifier.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPort number.\nIndicates that the guest OS has found the device and …\nIndicates that the device has experienced an error from …\nIndicates that the guest OS knows how to drive the device.\nIndicates that the driver is set up and ready to drive the …\nThe device status field. Writing 0 into this field resets …\nTypes of virtio devices.\nIndicates that something went wrong in the guest, and it …\nIndicates that the driver has acknowledged all the …\nA VirtIO transport layer.\nAcknowledges an interrupt.\nGet a flags value with all known bits set.\nBegins initializing the device.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nGets the pointer to the config space.\nWhether all set bits in a source flags value are also set …\nGets the device type.\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nFinishes initializing the device.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGets the device status.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nGets the max size of the given queue.\nMMIO transport for VirtIO.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nNotifies the given queue on the device.\nPCI transport for VirtIO.\nSets up the given queue.\nDisables and resets the given queue.\nReturns whether the queue is in use, i.e. has a nonzero …\nReads device features.\nThe intersection of a source flags value with the …\nReturns whether the transport requires queues to use the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSets the guest page size.\nSets the device status.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWrites device features.\nThe header doesn’t start with the expected magic value …\nLegacy MMIO transport with page-based addressing.\nAn error encountered initialising a VirtIO MMIO transport.\nMMIO Device Register Interface.\nThe version of the VirtIO MMIO transport supported by a …\nModern MMIO transport.\nThe header reports a version number that is neither 1 …\nMMIO Device Register Interface, both legacy and modern.\nThe header reports a device ID of 0.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new VirtIO MMIO transport, or returns an …\nGets the vendor ID.\nGets the version of the VirtIO MMIO transport.\nA BAR which we need was not allocated an address.\nThe offset for some capability was greater than the length …\n<code>VIRTIO_PCI_CAP_NOTIFY_CFG</code> capability has a …\nPCI device vender ID was not the VirtIO vendor ID.\nThe virtual address was not aligned as expected.\nNo valid <code>VIRTIO_PCI_CAP_COMMON_CFG</code> capability was found.\nNo valid <code>VIRTIO_PCI_CAP_ISR_CFG</code> capability was found.\nNo valid <code>VIRTIO_PCI_CAP_NOTIFY_CFG</code> capability was found.\nA generic PCI error,\nPCI transport for VirtIO.\nAn IO BAR was provided rather than a memory BAR.\nAn error encountered initialising a VirtIO PCI transport.\nModule for dealing with a PCI bus in general, without …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new PCI VirtIO device driver for the given …\nReturns the type of VirtIO device to which the given PCI …\nThe expected alignment in bytes.\nThe virtual address in question.\nThe device can behave as a bus master.\nInformation about a PCI Base Address Register.\nThe BAR must be mapped below 1MiB.\nAn iterator which enumerates PCI devices and functions on …\nThe device has a linked list of capabilities.\nA PCI Configuration Access Mechanism.\nInformation about a PCI device capability.\nIterator over capabilities for a device.\nThe command register in PCI configuration space.\nThe device detects a parity error, even if parity error …\nAn identifier for a PCI bus, device and function.\nInformation about a PCI device function.\nThe PCIe memory-mapped Enhanced Configuration Access …\nThe device can accept fast back-to-back transactions not …\nThe device is allowed to generate fast back-to-back …\nThe type of a PCI device function header.\nAssertion of the device’s INTx# signal is disabled.\nThe state of the device’s INTx# signal.\nThe BAR is for an I/O region.\nThe device can respond to I/O Space accesses.\nThe device reported an invalid BAR type.\nThe bus agent observed a parity error (if parity error …\nThe device can respond to Memory Space accesses.\nThe device can generate the Memory Write and Invalidate …\nThe device is capabile of running at 66 MHz rather than 33 …\nThe BAR is for a memory region.\nThe location allowed for a memory BAR.\nThe PCI memory-mapped Configuration Access Mechanism.\nThe device should take its normal action when a parity …\nID for vendor-specific PCI capabilities.\nA PCI to CardBus bridge.\nErrors accessing a PCI device.\nA PCI to PCI bridge.\nThe root complex of a PCI bus.\nA master device transaction was terminated with …\nA master device transaction was terminated with …\nThe SERR# driver is enabled.\nA device asserts SERR#.\nA target device terminated a transaction with target-abort.\nThe device can monitor Special Cycle operations.\nA normal PCI device.\nThe status register in PCI configuration space.\nUnrecognised header type.\nThe device will snoop palette register data.\nThe BAR has a 32-bit address and can be mapped anywhere in …\nThe BAR has a 64-bit address and can be mapped anywhere in …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGets information about the given BAR of the given device …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe PCI bus number, between 0 and 255.\nGets an iterator over the capabilities of the given device …\nThe PCI class.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe device number on the bus, between 0 and 31.\nThe PCI device ID.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nEnumerates PCI devices on the given bus.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe function number of the device, between 0 and 7.\nReads the status and command registers of the given device …\nThe type of PCI device.\nThe ID of the capability.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nReturns the address and size of this BAR if it is a memory …\nWraps the PCI root complex with the given MMIO base …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe offset of the capability in the PCI configuration …\nThe third and fourth bytes of the capability, to save …\nThe PCI programming interface byte.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe PCI revision ID.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSets the address of the given 32-bit memory or I/O BAR of …\nSets the address of the given 64-bit memory BAR of the …\nSets the command register of the given device function.\nReturns the total size in bytes of the memory-mapped …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe PCI subclass.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns whether this BAR is a 64-bit memory region, and so …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns whether the device and function numbers are valid, …\nThe PCI vendor ID.\nThe memory address, always 16-byte aligned.\nThe I/O address, always 4-byte aligned.\nThe size of the BAR address and where it can be located.\nIf true, then reading from the region doesn’t have side …\nThe size of the BAR in bytes.\nThe size of the BAR in bytes.")